import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { createServer } from 'http';
import { Server } from 'socket.io';
import connectDB from './config/database.js';
import Form from './models/Form.js';
import Submission from './models/Submission.js';
import aiRoutes from './routes/aiRoutes.js';
import formsRoutes from './routes/formsRoutes.js';
import healthRoutes from './routes/healthRoutes.js';
import { conversationHistoryService } from './services/conversationHistoryService.js';
import { personalityConfig, getContextualGreeting } from './config/personality.js';
import { guardrailsEngine } from './config/guardrails.js';
import EnhancedFormHandlers from './websocket/enhancedFormHandlers.js';
import configValidator from './utils/configValidator.js';

dotenv.config();

// Connect to MongoDB
connectDB();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});
const PORT = process.env.PORT || 5000;

// Helper functions for context-aware responses
function buildContextAwarePrompt(message, context) {
  const { userType, conversationHistory, userPreferences, keyTopics } = context;
  
  let prompt = `B·∫°n l√† FormAgent AI, m·ªôt tr·ª£ l√Ω th√¥ng minh chuy√™n t·∫°o form v√† tr√≤ chuy·ªán th√¢n thi·ªán.\n\n`;
  
  // Add user context
  if (userType !== 'firstTime') {
    prompt += `Ng∆∞·ªùi d√πng l√† ${userType === 'expert' ? 'chuy√™n gia' : 'ng∆∞·ªùi d√πng quen thu·ªôc'}.\n`;
  }
  
  // Add conversation history context
  if (conversationHistory && conversationHistory.length > 0) {
    prompt += `Ng·ªØ c·∫£nh cu·ªôc tr√≤ chuy·ªán:\n`;
    conversationHistory.slice(-3).forEach(msg => {
      prompt += `- ${msg.role}: ${msg.content.substring(0, 100)}...\n`;
    });
  }
  
  // Add user preferences
  if (userPreferences && userPreferences.previousForms && userPreferences.previousForms.length > 0) {
    prompt += `Ng∆∞·ªùi d√πng ƒë√£ t·∫°o ${userPreferences.previousForms.length} form tr∆∞·ªõc ƒë√≥.\n`;
  }
  
  // Add key topics
  if (keyTopics && keyTopics.length > 0) {
    prompt += `Ch·ªß ƒë·ªÅ quan t√¢m: ${keyTopics.map(t => t.topic).join(', ')}.\n`;
  }
  
  prompt += `\nTin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng: "${message}"\n\nH√£y tr·∫£ l·ªùi m·ªôt c√°ch t·ª± nhi√™n, th√¢n thi·ªán v√† ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh:`;
  
  return prompt;
}

function generateContextualFallbackResponse(message, context) {
  const { userType, userPreferences, keyTopics } = context;
  const lowerMessage = message.toLowerCase();
  
  // Personalized greeting
  if (lowerMessage.includes('xin ch√†o') || lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
    let response = `Xin ch√†o! T√¥i l√† FormAgent AI ü§ñ\n\n`;
    
    if (userType === 'returning') {
      response += `R·∫•t vui ƒë∆∞·ª£c g·∫∑p l·∫°i b·∫°n! `;
    } else if (userType === 'expert') {
      response += `Ch√†o b·∫°n! S·∫µn s√†ng cho m·ªôt d·ª± √°n form m·ªõi? `;
    }
    
    if (userPreferences && userPreferences.previousForms && userPreferences.previousForms.length > 0) {
      const lastForm = userPreferences.previousForms.slice(-1)[0];
      response += `\nüìã L·∫ßn tr∆∞·ªõc b·∫°n ƒë√£ t·∫°o "${lastForm.title}".`;
    }
    
    response += `\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\nüìù T·∫°o form ƒëƒÉng k√Ω, kh·∫£o s√°t, ph·∫£n h·ªìi\nüí¨ Tr√≤ chuy·ªán v√† t∆∞ v·∫•n\nüîß Thi·∫øt k·∫ø form chuy√™n nghi·ªáp\n\nB·∫°n mu·ªën l√†m g√¨ h√¥m nay?`;
    
    return response;
  }
  
  // Contextual help
  if (lowerMessage.includes('l√†m g√¨') || lowerMessage.includes('gi√∫p g√¨')) {
    let response = `T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n\n`;
    
    if (keyTopics && keyTopics.length > 0) {
      response += `üîç D·ª±a tr√™n cu·ªôc tr√≤ chuy·ªán, b·∫°n quan t√¢m ƒë·∫øn: ${keyTopics.map(t => t.topic).join(', ')}\n\n`;
    }
    
    response += `üöÄ **T·∫°o form nhanh ch√≥ng:**\n- "T·∫°o form ƒëƒÉng k√Ω s·ª± ki·ªán"\n- "T·∫°o kh·∫£o s√°t kh√°ch h√†ng"\n- "T·∫°o form ph·∫£n h·ªìi"\n\nüí° **T∆∞ v·∫•n thi·∫øt k·∫ø:**\n- C√°ch thi·∫øt k·∫ø form hi·ªáu qu·∫£\n- Lo·∫°i tr∆∞·ªùng n√†o ph√π h·ª£p\n- C·∫•u h√¨nh email v√† API\n\nB·∫°n mu·ªën th·ª≠ t·∫°o form kh√¥ng?`;
    
    return response;
  }
  
  // Default contextual response
  let response = `T√¥i hi·ªÉu b·∫°n ƒëang h·ªèi v·ªÅ: "${message}"\n\n`;
  
  if (userType === 'expert') {
    response += `V·ªõi kinh nghi·ªám c·ªßa b·∫°n, t√¥i c√≥ th·ªÉ h·ªó tr·ª£:\n‚Ä¢ Advanced form validation\n‚Ä¢ Custom field types\n‚Ä¢ API integrations\n‚Ä¢ Performance optimization\n\n`;
  } else {
    response += `T√¥i l√† FormAgent AI, chuy√™n gia v·ªÅ t·∫°o form! üéØ\n\n`;
  }
  
  response += `M·ªôt s·ªë g·ª£i √Ω:\n‚Ä¢ H·ªèi "l√†m th·∫ø n√†o ƒë·ªÉ t·∫°o form hi·ªáu qu·∫£?"\n‚Ä¢ Th·ª≠ n√≥i "t·∫°o form ƒëƒÉng k√Ω workshop"\n‚Ä¢ Ho·∫∑c h·ªèi b·∫•t c·ª© ƒëi·ªÅu g√¨ v·ªÅ form v√† thi·∫øt k·∫ø!\n\nB·∫°n mu·ªën t√¥i gi√∫p g√¨ kh√°c?`;
  
  return response;
}

// Rate limiting
const limiter = rateLimit({
  windowMs: process.env.RATE_LIMIT_WINDOW_MS || 15 * 60 * 1000, // 15 minutes
  max: process.env.RATE_LIMIT_MAX_REQUESTS || 100,
  message: 'Too many requests from this IP, please try again later.'
});

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(morgan('combined'));
app.use(limiter);
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// WebSocket connection handling
io.on('connection', (socket) => {
  console.log(`üîå Client connected: ${socket.id}`);
  
  socket.on('disconnect', () => {
    console.log(`üîå Client disconnected: ${socket.id}`);
  });
  
  socket.on('join-room', (room) => {
    socket.join(room);
    console.log(`üè† Client ${socket.id} joined room: ${room}`);
  });

  // Handle form generation via WebSocket with persistent context
  socket.on('generate-form', async (data) => {
    try {
      console.log(`üìù Form generation request from ${socket.id}:`, data);
      
      const { 
        description, 
        requirements = {}, 
        autoSave = false, 
        useCrewAI = true,
        conversationId = `conv_${Date.now()}_${socket.id}`,
        userId = 'anonymous'
      } = data;

      // Get or create conversation with persistent context
      const conversation = await conversationHistoryService.getOrCreateConversation(
        conversationId, 
        userId, 
        socket.id
      );

      // Add user message to conversation history
      await conversationHistoryService.addMessage(conversationId, {
        role: 'user',
        content: `T·∫°o form: ${description}`,
        metadata: { 
          type: 'form_generation_request',
          requirements: requirements
        }
      }, userId);

      // Get conversation context for personalized generation
      const context = await conversationHistoryService.getConversationContext(conversationId);
      const greeting = await conversationHistoryService.getContextualGreeting(conversationId, userId);
      
      // Send personalized acknowledgment
      socket.emit('form-generation-started', {
        success: true,
        message: 'ƒêang t·∫°o form...',
        personalizedMessage: greeting.personalTouch,
        suggestions: greeting.tips,
        timestamp: new Date().toISOString()
      });

      // Check content safety with guardrails
      const safetyCheck = guardrailsEngine.checkContentSafety(description);
      if (!safetyCheck.safe) {
        await conversationHistoryService.addMessage(conversationId, {
          role: 'system',
          content: 'Content safety violation detected',
          metadata: { violations: safetyCheck.violations }
        }, userId);
        
        socket.emit('form-generation-error', {
          success: false,
          error: 'N·ªôi dung kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch b·∫£o m·∫≠t',
          details: safetyCheck.violations,
          timestamp: new Date().toISOString()
        });
        return;
      }
      
      // Import AI services
      const aiService = (await import('./services/aiService.js')).default;
      const enhancedAgentService = (await import('./services/crewAIService.js')).default;
      
      let generatedForm;
      let service = 'fallback-template';

      // Enhanced requirements with conversation context
      const enhancedRequirements = {
        ...requirements,
        context: context,
        userPreferences: context.userPreferences,
        previousForms: context.userPreferences.previousForms,
        userType: context.userType,
        conversationHistory: context.shortTerm.slice(-5) // Last 5 messages for context
      };

      // Try Enhanced service first with context
      if (useCrewAI && enhancedAgentService.isEnabled()) {
        try {
          generatedForm = await enhancedAgentService.generateForm(description, enhancedRequirements);
          service = 'LangChain';
        } catch (crewError) {
          console.error('LangChain form generation error:', crewError);
          // Fall back to legacy service
          if (aiService.isEnabled()) {
            try {
              generatedForm = await aiService.generateFormFields(description, requirements);
              service = 'legacy-fallback';
            } catch (legacyError) {
              console.error('Legacy AI service error:', legacyError);
              // Use fallback template
              const { generateDefaultForm } = await import('./utils/formTemplates.js');
              generatedForm = generateDefaultForm(description, requirements);
              service = 'fallback-template';
            }
          } else {
            // Use fallback template
            const generateDefaultForm = (await import('./utils/formTemplates.js')).generateDefaultForm;
            generatedForm = generateDefaultForm(description, requirements);
            service = 'fallback-template';
          }
        }
      } else if (aiService.isEnabled()) {
        try {
          generatedForm = await aiService.generateFormFields(description, requirements);
          service = 'legacy';
        } catch (legacyError) {
          console.error('Legacy AI service main error:', legacyError);
          // Use fallback template
          const generateDefaultForm = (await import('./utils/formTemplates.js')).generateDefaultForm;
          generatedForm = generateDefaultForm(description, requirements);
          service = 'fallback-template';
        }
      } else {
        // Use fallback template
        const generateDefaultForm = (await import('./utils/formTemplates.js')).generateDefaultForm;
        generatedForm = generateDefaultForm(description, requirements);
        service = 'fallback-template';
      }

      // Validate generated form with guardrails
      const formValidation = guardrailsEngine.validateFormDesign(generatedForm);
      
      // Add assistant response to persistent conversation history
      await conversationHistoryService.addMessage(conversationId, {
        role: 'assistant',
        content: `ƒê√£ t·∫°o form "${generatedForm.title}" v·ªõi ${generatedForm.fields.length} tr∆∞·ªùng`,
        metadata: { 
          type: 'form_generation_response',
          service: service,
          formData: generatedForm,
          validationIssues: formValidation.issues
        }
      }, userId);

      // Record form creation in conversation history if auto-save
      if (autoSave) {
        try {
          const form = new Form({
            title: generatedForm.title,
            description: generatedForm.description,
            fields: generatedForm.fields,
            settings: {
              aiGenerated: true,
              generationPrompt: description,
              generationRequirements: enhancedRequirements
            },
            metadata: {
              conversationId: conversationId,
              userId: userId,
              service: service
            }
          });

          const savedForm = await form.save();
          await conversationHistoryService.recordFormCreation(conversationId, savedForm);
          console.log('Form auto-saved and recorded in conversation:', savedForm._id);
        } catch (saveError) {
          console.error('Failed to auto-save form:', saveError);
        }
      }

      // Send successful result with context
      socket.emit('form-generated', {
        success: true,
        generatedForm,
        conversationId,
        context: {
          userType: context.userType,
          suggestions: greeting.tips,
          previousFormsCount: context.userPreferences.previousForms.length,
          keyTopics: context.keyTopics.slice(0, 3)
        },
        metadata: {
          generatedAt: new Date().toISOString(),
          service: service,
          provider: service === 'LangChain' ? 'azure' : 'template',
          autoSaved: autoSave,
          safetyWarnings: safetyCheck.warnings,
          validationIssues: formValidation.issues,
          conversationLength: context.shortTerm.length
        }
      });

    } catch (error) {
      console.error('WebSocket form generation error:', error);
      socket.emit('form-generation-error', {
        success: false,
        error: 'Failed to generate form',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Handle chat via WebSocket with persistent context
  socket.on('chat-message', async (data) => {
    try {
      console.log(`üí¨ Chat message from ${socket.id}:`, data);
      
      const { 
        message, 
        conversation_id, 
        context = {}, 
        useCrewAI = true,
        userId = 'anonymous'
      } = data;
      
      const conversationId = conversation_id || `chat_${Date.now()}_${socket.id}`;

      // Get or create conversation with persistent context
      const conversation = await conversationHistoryService.getOrCreateConversation(
        conversationId, 
        userId, 
        socket.id
      );

      // Check content safety
      const safetyCheck = guardrailsEngine.checkContentSafety(message);
      if (!safetyCheck.safe) {
        await conversationHistoryService.addMessage(conversationId, {
          role: 'system',
          content: 'Content safety violation in chat',
          metadata: { violations: safetyCheck.violations }
        }, userId);
        
        socket.emit('chat-error', {
          success: false,
          error: 'N·ªôi dung kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch b·∫£o m·∫≠t',
          timestamp: new Date().toISOString()
        });
        return;
      }

      // Add user message to conversation history
      await conversationHistoryService.addMessage(conversationId, {
        role: 'user',
        content: message,
        metadata: { 
          type: 'chat_message',
          socketId: socket.id
        }
      }, userId);

      // Get conversation context for personalized responses
      const persistentContext = await conversationHistoryService.getConversationContext(conversationId);
      const greeting = await conversationHistoryService.getContextualGreeting(conversationId, userId);
      
      // Send personalized typing indicator
      socket.emit('chat-typing', {
        typing: true,
        personalizedMessage: greeting.topicSuggestion,
        timestamp: new Date().toISOString()
      });

      // Import AI services
      const aiService = (await import('./services/aiService.js')).default;
      const enhancedAgentService = (await import('./services/crewAIService.js')).default;
      
      let response;
      let service = 'fallback';

      // Enhanced context with conversation history
      const enhancedContext = {
        ...context,
        ...persistentContext,
        language: 'Vietnamese',
        conversationHistory: persistentContext.shortTerm,
        userPreferences: persistentContext.userPreferences,
        userType: persistentContext.userType,
        keyTopics: persistentContext.keyTopics,
        personality: personalityConfig.personality,
        guidelines: persistentContext.guidelines
      };

      // Try LangChain first with persistent context
      if (useCrewAI && enhancedAgentService.isEnabled()) {
        try {
          const chatResponse = await enhancedAgentService.handleChatMessage(
            message,
            conversationId,
            enhancedContext
          );
          
          response = chatResponse.response;
          service = 'LangChain';
        } catch (crewError) {
          console.error('LangChain chat error:', crewError);
          // Fall through to legacy service
        }
      }

      // Try legacy AI service with context if LangChain failed
      if (!response && aiService.isEnabled()) {
        try {
          // Build context-aware prompt
          const contextPrompt = buildContextAwarePrompt(message, enhancedContext);
          response = await aiService.generateCompletion(contextPrompt);
          service = 'legacy';
        } catch (aiError) {
          console.error('Legacy AI chat error:', aiError);
          // Fall through to default response
        }
      }

      // Context-aware default responses
      if (!response) {
        response = generateContextualFallbackResponse(message, enhancedContext);
        service = 'fallback';
      }

      // Improve response quality with guardrails
      response = guardrailsEngine.improveResponse(response, {
        conversationHistory: persistentContext.shortTerm,
        userType: persistentContext.userType,
        topic: 'chat'
      });

      // Add assistant response to conversation history
      await conversationHistoryService.addMessage(conversationId, {
        role: 'assistant',
        content: response,
        metadata: { 
          type: 'chat_response',
          service: service,
          safetyWarnings: safetyCheck.warnings
        }
      }, userId);

      // Stop typing and send enhanced response
      socket.emit('chat-typing', { typing: false });
      socket.emit('chat-response', {
        success: true,
        response: response,
        conversation_id: conversationId,
        service: service,
        context: {
          userType: persistentContext.userType,
          suggestions: greeting.tips,
          previousFormsCount: persistentContext.userPreferences.previousForms.length,
          keyTopics: persistentContext.keyTopics.slice(0, 3),
          conversationLength: persistentContext.shortTerm.length
        },
        metadata: {
          safetyWarnings: safetyCheck.warnings,
          personalizedGreeting: greeting.personalTouch
        },
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('WebSocket chat error:', error);
      socket.emit('chat-typing', { typing: false });
      socket.emit('chat-error', {
        success: false,
        error: 'Failed to process chat message',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Validate and initialize enhanced form handlers
  const aiConfig = {
    provider: process.env.AI_PROVIDER || 'openai',
    apiKey: process.env.OPENAI_API_KEY || process.env.AZURE_OPENAI_API_KEY || process.env.AZURE_OPENAI_KEY,
    endpoint: process.env.AZURE_OPENAI_ENDPOINT,
    deployment: process.env.AZURE_OPENAI_DEPLOYMENT_NAME || process.env.AZURE_OPENAI_DEPLOYMENT,
    apiVersion: process.env.AZURE_OPENAI_API_VERSION || '2024-02-15-preview',
    model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
    temperature: 0.7,
    maxTokens: 2000
  };

  // Log configuration status for debugging
  configValidator.logConfigStatus(aiConfig);

  // Test configuration
  configValidator.testAIConfig(aiConfig)
    .then(testResult => {
      configValidator.logConfigStatus(aiConfig, testResult);
      if (!testResult.success) {
        console.warn('‚ö†Ô∏è AI service may not work properly. Using fallback responses.');
      }
    })
    .catch(error => {
      console.error('Failed to test AI configuration:', error);
    });

  const enhancedHandlers = new EnhancedFormHandlers(aiConfig);

  // Handle enhanced chat with form context
  socket.on('chat-message-with-context', async (data) => {
    await enhancedHandlers.handleChatWithFormContext(socket, data);
  });

  // Handle form status queries
  socket.on('form-status', async (data) => {
    await enhancedHandlers.handleFormStatusQuery(socket, data);
  });

  // Handle form manipulation
  socket.on('form-manipulate', async (data) => {
    await enhancedHandlers.handleFormManipulation(socket, data);
  });

  // Handle form save requests
  socket.on('form-save', async (data) => {
    await enhancedHandlers.handleFormSave(socket, data);
  });
});

// Form processing service with AI analysis
const processFormWithAI = async (prompt) => {
  // Simulate AI processing delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  const lowerPrompt = prompt.toLowerCase();
  const fields = [];
  let title = 'Form th√¥ng tin';
  let description = 'Vui l√≤ng ƒëi·ªÅn th√¥ng tin b√™n d∆∞·ªõi';
  let introduction = 'ƒê√¢y l√† form thu th·∫≠p th√¥ng tin ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông.';
  let triggerPhrases = ['th√¥ng tin', 'form'];

  // Enhanced AI analysis logic
  if (lowerPrompt.includes('ƒëƒÉng k√Ω') || lowerPrompt.includes('registration')) {
    title = 'Form ƒëƒÉng k√Ω';
    description = 'Form ƒëƒÉng k√Ω th√¥ng tin';
    introduction = 'Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin ƒë·ªÉ ho√†n t·∫•t qu√° tr√¨nh ƒëƒÉng k√Ω.';
    triggerPhrases = ['ƒëƒÉng k√Ω', 'registration', 'sign up'];
  }

  if (lowerPrompt.includes('kh√≥a h·ªçc') || lowerPrompt.includes('course')) {
    title = 'Form ƒëƒÉng k√Ω kh√≥a h·ªçc';
    description = 'ƒêƒÉng k√Ω tham gia kh√≥a h·ªçc';
    introduction = 'ƒêƒÉng k√Ω kh√≥a h·ªçc ƒë·ªÉ nh·∫≠n ƒë∆∞·ª£c th√¥ng tin chi ti·∫øt v√† ƒë∆∞·ª£c t∆∞ v·∫•n.';
    triggerPhrases = ['kh√≥a h·ªçc', 'course', 'ƒë√†o t·∫°o'];
  }

  if (lowerPrompt.includes('li√™n h·ªá') || lowerPrompt.includes('contact')) {
    title = 'Form li√™n h·ªá';
    description = 'G·ª≠i th√¥ng tin li√™n h·ªá';
    introduction = 'Ch√∫ng t√¥i s·∫Ω li√™n h·ªá v·ªõi b·∫°n trong th·ªùi gian s·ªõm nh·∫•t.';
    triggerPhrases = ['li√™n h·ªá', 'contact', 'h·ªó tr·ª£'];
  }

  // Add fields based on prompt content
  if (lowerPrompt.includes('t√™n') || lowerPrompt.includes('h·ªç') || lowerPrompt.includes('name')) {
    fields.push({
      id: 'name',
      label: 'H·ªç v√† t√™n',
      type: 'text',
      required: true,
      placeholder: 'Nh·∫≠p h·ªç v√† t√™n...'
    });
  }

  if (lowerPrompt.includes('email')) {
    fields.push({
      id: 'email',
      label: 'Email',
      type: 'email',
      required: true,
      placeholder: 'example@email.com'
    });
  }

  if (lowerPrompt.includes('ƒëi·ªán tho·∫°i') || lowerPrompt.includes('sdt') || lowerPrompt.includes('phone')) {
    fields.push({
      id: 'phone',
      label: 'S·ªë ƒëi·ªán tho·∫°i',
      type: 'tel',
      required: true,
      placeholder: '0123456789'
    });
  }

  if (lowerPrompt.includes('tu·ªïi') || lowerPrompt.includes('age')) {
    fields.push({
      id: 'age',
      label: 'Tu·ªïi',
      type: 'number',
      required: false,
      placeholder: 'Nh·∫≠p tu·ªïi...'
    });
  }

  if (lowerPrompt.includes('ƒë·ªãa ch·ªâ') || lowerPrompt.includes('address')) {
    fields.push({
      id: 'address',
      label: 'ƒê·ªãa ch·ªâ',
      type: 'textarea',
      required: false,
      placeholder: 'Nh·∫≠p ƒë·ªãa ch·ªâ...'
    });
  }

  if (lowerPrompt.includes('kinh nghi·ªám') || lowerPrompt.includes('experience')) {
    fields.push({
      id: 'experience',
      label: 'M·ª©c ƒë·ªô kinh nghi·ªám',
      type: 'select',
      required: true,
      placeholder: 'Ch·ªçn m·ª©c ƒë·ªô kinh nghi·ªám',
      options: ['M·ªõi b·∫Øt ƒë·∫ßu', 'Trung b√¨nh', 'C√≥ kinh nghi·ªám', 'Chuy√™n gia']
    });
  }

  if (lowerPrompt.includes('gi·ªõi t√≠nh') || lowerPrompt.includes('gender')) {
    fields.push({
      id: 'gender',
      label: 'Gi·ªõi t√≠nh',
      type: 'radio',
      required: false,
      options: ['Nam', 'N·ªØ', 'Kh√°c']
    });
  }

  if (lowerPrompt.includes('s·ªü th√≠ch') || lowerPrompt.includes('hobby') || lowerPrompt.includes('interest')) {
    fields.push({
      id: 'interests',
      label: 'S·ªü th√≠ch',
      type: 'checkbox',
      required: false,
      options: ['ƒê·ªçc s√°ch', 'Du l·ªãch', 'Th·ªÉ thao', '√Çm nh·∫°c', 'C√¥ng ngh·ªá']
    });
  }

  if (lowerPrompt.includes('ng√†y sinh') || lowerPrompt.includes('birthday') || lowerPrompt.includes('date')) {
    fields.push({
      id: 'birthday',
      label: 'Ng√†y sinh',
      type: 'date',
      required: false,
      placeholder: 'Ch·ªçn ng√†y sinh'
    });
  }

  if (lowerPrompt.includes('ghi ch√∫') || lowerPrompt.includes('note') || lowerPrompt.includes('message')) {
    fields.push({
      id: 'note',
      label: 'Ghi ch√∫',
      type: 'textarea',
      required: false,
      placeholder: 'Nh·∫≠p ghi ch√∫ (t√πy ch·ªçn)...'
    });
  }

  // Default fields if none detected
  if (fields.length === 0) {
    fields.push(
      {
        id: 'name',
        label: 'H·ªç v√† t√™n',
        type: 'text',
        required: true,
        placeholder: 'Nh·∫≠p h·ªç v√† t√™n...'
      },
      {
        id: 'email',
        label: 'Email',
        type: 'email',
        required: true,
        placeholder: 'example@email.com'
      }
    );
  }

  return {
    title,
    description,
    introduction,
    startDate: new Date().toISOString().split('T')[0],
    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    triggerPhrases,
    emailConfig: {
      enabled: true,
      recipientEmail: 'admin@company.com',
      subject: 'New form submission: ' + title,
      template: 'C√≥ form submission m·ªõi t·ª´ ' + title
    },
    apiConfig: {
      enabled: false,
      endpoint: '',
      method: 'POST',
      headers: {},
      customHeaders: ''
    },
    fields
  };
};

// New API endpoint for form processing with WebSocket
app.post('/api/process-form', async (req, res) => {
  try {
    const { prompt, clientId } = req.body;
    
    if (!prompt) {
      return res.status(400).json({ 
        success: false,
        error: 'Prompt is required' 
      });
    }

    // Send immediate response to web client
    res.json({ 
      success: true,
      message: 'Form processing started',
      clientId: clientId || 'default'
    });

    // Process form in background and send via WebSocket
    try {
      const processedForm = await processFormWithAI(prompt);
      
      // Send processed form via WebSocket
      if (clientId) {
        io.to(clientId).emit('form-processed', {
          success: true,
          form: processedForm,
          prompt,
          timestamp: new Date().toISOString()
        });
      } else {
        io.emit('form-processed', {
          success: true,
          form: processedForm,
          prompt,
          timestamp: new Date().toISOString()
        });
      }
    } catch (processError) {
      console.error('Form processing error:', processError);
      io.to(clientId || 'default').emit('form-processed', {
        success: false,
        error: 'Failed to process form',
        message: processError.message,
        timestamp: new Date().toISOString()
      });
    }
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to start form processing',
      message: error.message 
    });
  }
});

// Routes
app.use('/api/ai', aiRoutes);
app.use('/api/forms-enhanced', formsRoutes);
app.use('/api', healthRoutes);

// Forms API endpoints
app.get('/api/forms', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const forms = await Form.find({ isActive: true })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .populate('submissionCount');

    const total = await Form.countDocuments({ isActive: true });

    res.json({ 
      success: true,
      forms,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch forms',
      message: error.message 
    });
  }
});

app.post('/api/forms', async (req, res) => {
  try {
    const { title, description, fields, settings } = req.body;
    
    if (!title) {
      return res.status(400).json({ 
        success: false,
        error: 'Title is required' 
      });
    }

    const form = new Form({
      title,
      description,
      fields: fields || [],
      settings: settings || {}
    });

    await form.save();
    
    res.status(201).json({ 
      success: true,
      message: 'Form created successfully',
      form
    });
  } catch (error) {
    res.status(400).json({ 
      success: false,
      error: 'Failed to create form',
      message: error.message 
    });
  }
});

app.get('/api/forms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const form = await Form.findById(id).populate('submissionCount');
    
    if (!form) {
      return res.status(404).json({ 
        success: false,
        error: 'Form not found' 
      });
    }

    // Increment view count
    await Form.findByIdAndUpdate(id, { $inc: { 'analytics.views': 1 } });

    res.json({ 
      success: true,
      form 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch form',
      message: error.message 
    });
  }
});

app.put('/api/forms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, fields, settings, isActive } = req.body;
    
    const form = await Form.findByIdAndUpdate(
      id,
      { title, description, fields, settings, isActive },
      { new: true, runValidators: true }
    );

    if (!form) {
      return res.status(404).json({ 
        success: false,
        error: 'Form not found' 
      });
    }
    
    res.json({ 
      success: true,
      message: 'Form updated successfully',
      form
    });
  } catch (error) {
    res.status(400).json({ 
      success: false,
      error: 'Failed to update form',
      message: error.message 
    });
  }
});

app.delete('/api/forms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const form = await Form.findByIdAndUpdate(
      id,
      { isActive: false },
      { new: true }
    );

    if (!form) {
      return res.status(404).json({ 
        success: false,
        error: 'Form not found' 
      });
    }
    
    res.json({ 
      success: true,
      message: 'Form deleted successfully'
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to delete form',
      message: error.message 
    });
  }
});

// Form submissions
app.post('/api/forms/:id/submit', async (req, res) => {
  try {
    const { id } = req.params;
    const formData = req.body;
    
    // Check if form exists and is active
    const form = await Form.findById(id);
    if (!form || !form.isActive) {
      return res.status(404).json({ 
        success: false,
        error: 'Form not found or inactive' 
      });
    }

    // Create submission
    const submission = new Submission({
      formId: id,
      data: formData,
      submissionInfo: {
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        referrer: req.get('Referer'),
        submissionTime: new Date()
      }
    });

    await submission.save();

    // Update form analytics
    await Form.findByIdAndUpdate(id, { 
      $inc: { 'analytics.submissions': 1 } 
    });
    
    res.status(201).json({ 
      success: true,
      message: 'Form submitted successfully',
      submissionId: submission._id
    });
  } catch (error) {
    res.status(400).json({ 
      success: false,
      error: 'Failed to submit form',
      message: error.message 
    });
  }
});

app.get('/api/forms/:id/submissions', async (req, res) => {
  try {
    const { id } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const submissions = await Submission.find({ formId: id })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Submission.countDocuments({ formId: id });

    res.json({ 
      success: true,
      submissions,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch submissions',
      message: error.message 
    });
  }
});

// Analytics endpoint
app.get('/api/forms/:id/analytics', async (req, res) => {
  try {
    const { id } = req.params;
    const form = await Form.findById(id);
    
    if (!form) {
      return res.status(404).json({ 
        success: false,
        error: 'Form not found' 
      });
    }

    const submissionStats = await Submission.aggregate([
      { $match: { formId: form._id } },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' },
            day: { $dayOfMonth: '$createdAt' }
          },
          count: { $sum: 1 }
        }
      },
      { $sort: { '_id.year': -1, '_id.month': -1, '_id.day': -1 } },
      { $limit: 30 }
    ]);

    res.json({
      success: true,
      analytics: {
        ...form.analytics.toObject(),
        dailySubmissions: submissionStats
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch analytics',
      message: error.message 
    });
  }
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    success: false,
    error: 'Something went wrong!',
    message: process.env.NODE_ENV === 'production' ? 'Internal server error' : err.message
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ 
    success: false,
    error: 'Route not found',
    path: req.originalUrl
  });
});

// Start server
server.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`üìä Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üåê Frontend URL: ${process.env.FRONTEND_URL || 'http://localhost:3000'}`);
  console.log(`üóÑÔ∏è  MongoDB URI: ${process.env.MONGODB_URI ? 'Connected' : 'Not configured'}`);
  console.log(`üîå WebSocket server ready`);
});